package org.example.model;

import org.example.DbUtil;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

public class Polaczenie {
    private final int id;
    private final int stacja1Id;
    private final int stacja2Id;
    // You could add 'odleglosc' here if you want Polaczenie objects to hold it
    // private final double odleglosc;

    public Polaczenie(int id, int stacja1Id, int stacja2Id /*, double odleglosc */) {
        this.id = id;
        this.stacja1Id = stacja1Id;
        this.stacja2Id = stacja2Id;
        // this.odleglosc = odleglosc;
    }

    // Getters...
    public int getId() { return id; }
    public int getStacja1Id() { return stacja1Id; }
    public int getStacja2Id() { return stacja2Id; }
    // public double getOdleglosc() { return odleglosc; }


    public static List<Polaczenie> pobierzWszystkie() {
        List<Polaczenie> lista = new ArrayList<>();
        // The Polaczenie object currently only stores IDs.
        // If you want it to store distance too, you'd fetch it and pass to constructor.
        String sql = "SELECT id, stacja1_id, stacja2_id, odleglosc FROM polaczenia_miedzy_stacjami";

        try (Connection conn = DbUtil.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                lista.add(new Polaczenie(
                        rs.getInt("id"),
                        rs.getInt("stacja1_id"),
                        rs.getInt("stacja2_id")
                        // rs.getDouble("odleglosc") // if constructor takes it
                ));
            }
        } catch (SQLException e) {
            System.err.println("Error fetching Polaczenia: " + e.getMessage());
            e.printStackTrace();
        }
        return lista;
    }

    public static Polaczenie znajdzBezposrednie(int a, int b) {
        // This method filters the list from pobierzWszystkie().
        // For better performance on large datasets, it could query the DB directly.
        for (Polaczenie p : pobierzWszystkie()) {
            if ((p.stacja1Id == a && p.stacja2Id == b) ||
                    (p.stacja1Id == b && p.stacja2Id == a)) {
                return p;
            }
        }
        return null;
    }

    /**
     * Adds a new connection between two stations to the database.
     * The 'id' for the connection is auto-generated by the database (SERIAL type).
     *
     * @param stacja1Id The ID of the first station.
     * @param stacja2Id The ID of the second station.
     * @param odleglosc The distance between the two stations.
     * @return true if the connection was added successfully, false otherwise.
     */
    public static boolean dodajPolaczenie(int stacja1Id, int stacja2Id, double odleglosc) {
        // SQL Table: polaczenia_miedzy_stacjami
        // Columns relevant for insert:
        //   stacja1_id INTEGER NOT NULL REFERENCES stacje (id)
        //   stacja2_id INTEGER NOT NULL REFERENCES stacje (id)
        //   odleglosc  NUMERIC(6, 2) NOT NULL
        //   id         SERIAL PRIMARY KEY (auto-generated)

        String sql = "INSERT INTO polaczenia_miedzy_stacjami (stacja1_id, stacja2_id, odleglosc) VALUES (?, ?, ?)";

        try (Connection conn = DbUtil.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, stacja1Id);
            pstmt.setInt(2, stacja2Id);
            pstmt.setDouble(3, odleglosc);

            int affectedRows = pstmt.executeUpdate();

            // executeUpdate() returns the number of rows affected.
            // For an INSERT operation, this should be 1 if successful.
            return affectedRows > 0;

        } catch (SQLException e) {
            System.err.println("Error adding connection: " + e.getMessage());
            // Common SQLStates to check:
            // - "23503": foreign_key_violation (if stacja1Id or stacja2Id don't exist in 'stacje' table)
            // - "23505": unique_violation (if you had a unique constraint on (stacja1_id, stacja2_id) for example)
            // Your current schema for polaczenia_miedzy_stacjami doesn't seem to have a unique constraint on the pair of stations,
            // so duplicates like (StationA -> StationB, 100km) and again (StationA -> StationB, 100km) or (StationB -> StationA, 100km)
            // are technically possible at the database level unless you add such a constraint.
            if ("23503".equals(e.getSQLState())) {
                System.err.println("DB Error: One or both station IDs for the connection do not exist in the 'stacje' table.");
            }
            e.printStackTrace();
            return false;
        }
    }
}